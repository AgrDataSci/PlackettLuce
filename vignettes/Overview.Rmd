---
title: "Introduction to PlackettLuce"
author:
- name: Heather Turner
  affiliation: Department of Statistics, University of Warwick, UK
- name: Jacob van Etten
  affiliation: Bioversity International, Costa Rica
- name: David Firth
  affiliation: Department of Statistics, University of Warwick, UK
- name: Ioannis Kosmidis
  affiliation: Department of Statistical Science, UCL, UK
package: PlackettLuce
output:
  BiocStyle::html_document2:
  BiocStyle::pdf_document2: default
abstract: |
  The **PlackettLuce** package implements a generalization of the model jointly
  attributed to @Plackett1975 and @Luce1959 for modelling rankings data. The
  generalization accomodates both ties (of any order) and partial rankings
  (rankings of only some items). By default, the implementation adds a set
  pseudo-rankings with a hypothetical item, ensuring that the network of wins
  and losses is always strongly connected, i.e. all items are connected to every
  other item by both a path of wins and a path of losses. This means that the
  worth of each item is always estimable with finite standard error. It also has
  a shrinkage effect, regularizing the estimated parameters. In addition to
  standard methods for model summary, **PlackettLuce** provides a method to
  estimate quasi-standard errors for the item parameters, so that comparison
  intervals can be derived even when a reference item is set. Finally the
  package provides a method for model-based partitioning, enabling the
  identification of subgroups of subjects that rank items differently.
vignette: |
  %\VignetteIndexEntry{Introduction to PlackettLuce}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: ["plackettluce.bib"]
biblio-style: "apalike"
link-citations: true
---

```{r vignette-setup, include = FALSE}
library(knitr)
library(kableExtra)
options(knitr.table.format = "html")
```

# Introduction

Rankings data, in which each observation is an ordering of a set of items,
arises in a range of applications, for example sports tournaments and consumer
studies. A classic model for such data is the Plackett-Luce model. This model
depends on Luce's axiom of choice [@Luce1977] which states that the odds of
choosing item 1 over item 2 do not depend on the set of items from which the
choice is made. Suppose we have a set of $j$ items

$$S_j = \{i_1, i_2, \ldots, i_j\}.$$

Then under Luce's axiom, the probability of selecting item $i_j$ is given by

$$P(i_j | S_j) = \frac{\alpha_{i_j}}{\sum_{c \in S_j} \alpha_c}$$

where $\alpha_j$ represents the **worth** of item $i_j$. Viewing a ranking of $K$
items as a sequence of choices ---first choosing the top-ranked item from all
items, then choosing the second-ranked item from the remaining items and so
on--- it follows that the probability of the ranking ${i_K > \ldots > i_1}$ is

$$\prod_{j=1}^K \frac{\alpha_{i_j}}{\sum_{c \in S_j} \alpha_c}$$

The above model is also derived in @Plackett1975, hence the name Plackett-Luce
model.

The **PlackettLuce** package implements a novel extension of the Plackett-Luce
model that accommodates tied rankings, which may be applied to either full or
partial rankings. Pseudo-rankings are utilised to obtain estimates in cases
where the maximum likelihood estimates do not exist, or do not have finite
standard errors. Methods are provided to obtain different parameterisations with
corresponding standard errors or quasi-standard errors (that are independent of
the reference item). There is also a method to work with the **psychotree**
package to fit Plackett-Luce trees.

## Comparison with other packages

Even though the Plackett-Luce model is a well-established method for analysing
rankings, the software available to fit the model is limited. By considering
each choice in the ranking as a multinomial observation, with one item observed
out of a possible set, the "Poisson trick" [see, for example, @Baker1994] can be
applied to express the model as a log-linear model, where the response is the
count (one or zero) of each possible outcome within each choice. In theory, the
model can then be fitted using standard software for generalized linear
models. However there are a number of difficulties with this. Firstly, dummy
variables must be set up to represent the presense or absense of each item in
each choice and a factor created to identify each choice, which is a
non-standard task. Secondly the factor identifying each choice will have many
levels: greater than the number of rankings for rankings of more than two
objects. Thus there are many parameters to estimate and a standard function such
as `glm` will be slow to fit the model, or may even fail as the corresponding
model matrix will be too large to fit in memory. This issue can be circumvented
by using the `gnm` function from **gnm**, which provides an `eliminate` argument
to efficiently estimate the effects of such a factor. Even then, the
model-fitting may be relatively slow, given the expansion in the number of
observations converting from rankings to counts. For example, the ranking {item
3 > item 1 > item 2} expands to two choices with five counts all together:

```{r, echo = FALSE}
as.matrix(data.frame(choice = c(1, 1, 1, 2, 2),
                     `item 1` = c(1, 0, 0, 1, 0),
                     `item 2` = c(0, 1, 0, 0, 1),
                     `item 3` = c(0, 0, 1, 0, 0),
                     count = c(0, 0, 1, 1, 0), check.names = FALSE))

```

It is possible to aggregate observations of the same choice from the same set of
alternatives, but the number of combinations increases quickly with the number
of items.

Given the issues with applying general methods, custom algorithms and software
have been developed. One approach is use Hunter's [-@Hunter2004]
minorization-maximization (MM) algorithm to maximize the likelihood, which is
equivalent to an iterative scaling algorithm; this algorithm is used by the
**StatRank** package. Alternatively
the likelihood of the observed data under the PlackettLuce model can be
maximised directly using a generic optimisation method such the
Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm, as used by both the **pmr**
and **hyper2** packages. Finally Bayesian methods can be used to either
maximize the posterior distribution via an Expectation Maximization (EM)
algorithm or to simulate the posterior distribution using
Markov-chain Monte-Carlo (MCMC) techniques, both of which are provided by
**PLMIX**. **PlackettLuce** offers both iterative scaling and generic
optimization using either BFGS or a limited memory variant (L-BFGS) via the
**lbfgs** package.

Even some of these specialized implementations can scale poorly with the number
of items and/or the number of rankings as shown by the example timings in Table
\@ref(tab:timings-kable). Specifically `pmr::pl` becomes impractical to use with
a moderate number of items (~10), while the functions from **hyper2** and
**StatRank** take much longer to run with a large number (1000s) of unique
rankings. **PlackettLuce** copes well with these moderately-sized data sets,
though is not quite as fast as **PLMIX** when both the number of items and the
number of unique rankings is large.

```{r wrappers, echo = FALSE, cache = TRUE}
library(PlackettLuce)
# read in example data sets
preflib <- "http://www.preflib.org/data/election/"
netflix <- read.soc(file.path(preflib, "netflix/ED-00004-00000101.soc"))
tshirt <- read.soc(file.path(preflib, "shirt/ED-00012-00000001.soc"))
sushi <- read.soc(file.path(preflib, "sushi/ED-00014-00000001.soc"))

# wrappers for each method
pl <- function(dat, ...){
    # convert ordered items to ranking
    R <- as.rankings(dat[,-1], "ordering")
    # fit without adding pseudo-rankings, weight rankings by count
    PlackettLuce(R, npseudo = 0, weights = dat$n)
}
hyper2 <- function(dat, ...){
    requireNamespace("hyper2")
    # create likelihood object based on ordered items and counts
    H <- hyper2::hyper2(pnames = paste0("p", seq_len(ncol(dat) - 1)))
    for (i in seq_len(nrow(dat))){
        x <-  dat[i, -1][dat[i, -1] > 0]
        H <- H + hyper2::order_likelihood(x, times = dat[i, 1])
    }
    # find parameters to maximise likelihood
    p <- hyper2::maxp(H)
    structure(p, loglik = hyper2::lhyper2(H, p[-length(p)]))
}
plmix <- function(dat, ...){
    requireNamespace("PLMIX")
    # disaggregate data (no functionality for weights or counts)
    r <- rep(seq_len(nrow(dat)), dat$n)
    # maximum a posterioi estimate, with non-informative prior,
    # K items in each ranking, single component distribution
    # default starting values do not always work
    K <- ncol(dat)
    PLMIX::mapPLMIX(as.matrix(dat[r, -1]), K = K, G = 1,
                    init = list(p = rep.int(1/K, K)), plot_objective = FALSE)
}
pmr <- function(dat, ...){
    requireNamespace("pmr")
    # convert ordered items to ranking
    R <- as.rankings(dat[,-1], "ordering")
    # create data frame with counts as required by pl
    X <- as.data.frame(unclass(R))
    X$n <- dat$n
    capture.output(res <- pmr::pl(X))
    res
}
statrank <- function(dat, iter){
    requireNamespace("StatRank")
    # disaggregate data (no functionality for weights or counts)
    r <- rep(seq_len(nrow(dat)), dat$n)
    capture.output(res <- StatRank::Estimation.PL.MLE(as.matrix(dat[r, -1]),
                                                      iter = iter))
    res
}
timings <- function(dat, iter = NULL,
                    fun = c("pl", "hyper2", "plmix", "pmr", "statrank")){
    res <- list()
    for (nm in c("pl", "hyper2", "plmix", "pmr", "statrank")){
        if (nm %in% fun){
            res[[nm]] <- try(
                system.time(do.call(nm, list(dat, iter)))[["elapsed"]],
                silent = TRUE)
        } else res[[nm]] <- NA
    }
    res
}
```

```{r timings, echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE}
# set iter for statrank so that log-likelihood pass `all.equal` with tolerance 1e-6
netflix_timings <- timings(netflix, 6)
tshirt_timings <- timings(tshirt, 341)
sushi_timings <- timings(sushi, 5)
```

```{r data-features, echo = FALSE}
features <- cbind(c(1256, 30, 5000),
                  c(24, 30, 4926),
                  c(4, 11, 10))
dimnames(features) <- list(c("Netflix", "T-shirt", "Sushi"),
                           c("Rankings", "Unique rankings", "Items"))
kable(features,
      caption = "Features of example data sets from PrefLib [@Mattei2013]") %>%
    kable_styling()
```

```{r timings-kable, echo = FALSE}
res <- data.frame(netflix = round(unlist(netflix_timings), 3))
a <- gsub("[^0-9]*([0-9.]* Gb).*", "\\1", tshirt_timings$pmr)
tshirt_timings$pmr <- NA
res$tshirt <- formatC(unlist(tshirt_timings), digits = 3, format = "f")
res["pmr", "tshirt"] <- "a"
b <- gsub("[^0-9]*([0-9.]* Gb).*", "\\1", sushi_timings$pmr)
sushi_timings$pmr <- NA
res$sushi <- formatC(unlist(sushi_timings), digits = 3, format = "f")
res["pmr", "sushi"] <- "b"
res <- t(as.matrix(res))
dimnames(res) <- list(c("Netflix", "T-shirt", "Sushi"),
                      c("PlackettLuce",
                        "hyper2", "PLMIX", "pmr", "StatRank"))

kable(res, align = c("rrrrr"), caption = "Timings for fitting the
Plackett-Luce model to data sets summarised in Table \\@ref(tab:data-features) using
different packages. See Appendix for details and code.") %>%
    kable_styling() %>%
    add_header_above(c(" " = 1, "Time elapsed (s)" = 5)) %>%
    add_footnote(c(paste("Failed to allocate vector of size:", a),
                   paste("Failed to allocate vector of size:", b)),
                 notation = "alphabet")
```

When the number of items is more than ten, it is more common to
observe partial rankings than complete rankings. Partial rankings can be of two
types: *sub-rankings*, where only a subset of items are ranked each time, and
*incomplete rankings*, where the top $n$ items are selected and the remaining
items are unranked, but implictly ranked lower than the top $n$. Sub-rankings
are accommodated by the standard Plackett-Luce model, while incomplete rankings
require an extension of the Plackett-Luce model. **PlackettLuce** handles
sub-rankings only, while **PLMIX** handles incomplete rankings only and
**hyper2** can handle both types. (**StatRank** supports partial rankings, but
it is not clear in which form). Table \@ref(tab:nascar) demonstrates using the
NASCAR data from @Hunter2004 that **PlackettLuce** is more efficient than
**hyper2** for modelling subrankings of a relatively large number of items.

```{r timings-sub, echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE}
data(Data.Nascar, package = "StatRank")
# add column of frequencies so the format the same as before
nascar <- cbind(n = 1, Data.Nascar)
nascar_timings <- timings(nascar, fun = c("pl", "hyper2"))
```

```{r nascar, echo = FALSE}
res <- round(unlist(nascar_timings)[c("pl", "hyper2")], 3)
res <- data.frame(Rankings = 36,
                  Items = 83,
                  `Items per ranking` = "42-43",
                  PlackettLuce = res[1],
                  hyper2 = res[2],
                  check.names = FALSE, row.names = NULL)
kable(res, align = "rrrrr",
      caption = "Timings for fitting the Plackett-Luce model to the NASCAR data from @Hunter2004. All rankings are unique.") %>%
    kable_styling() %>%
    add_header_above(c("Features of NASCAR data" = 3, "Time elapsed (s)" = 2))
```

**PlackettLuce** is the only package out of those based on maximum likelihood
estimation with the functionality to compute standard errors for the item
parameters and thereby the facility to conduct inference on these parameters.
Using **PLMIX**, inference may be based on the posterior distribution. In some
cases, when the network of wins and losses is disconnected or weakly connected,
the maximum likelihood estimate does not exist, or has infinite standard
error; such issues are handled in **PlackettLuce** by utilising pseudo-rankings.
This is similar to incorporating prior information as in the Bayesian approach.

**PlackettLuce** is also the only package that can accommodate tied rankings,
through a novel extension of the Plackett-Luce model. On the other hand
**hyper2** is currently the only package that can handle rankings of
combinations of items, for example team rankings in sports. **PLMIX** offers the
facility to model heterogenous populations of subjects that have different sets
of worth parameters via mixture models. This is similar in spirit to the
model-based partitioning offered by **PlackettLuce**, except here the
sub-populations are defined by binary splits on subject attributes. A summary of
the package features is given in Table \@ref(tab:package-summary).

```{r package-summary, echo = FALSE}
tab <- data.frame(Feature = c("Inference", "Disconnected networks",
                              "Ties", "Teams", "Heterogenous case"),
                  PlackettLuce = c("Frequentist", "Yes", "Yes", "No", "Trees"),
                  hyper2 = c("No", "No", "No", "Yes", "No"),
                  pmr = c("No", "No", "No", "No", "No"),
                  StatRank = c("No", "No", "No", "No", "No"),
                  PLMIX = c("Bayesian", "Yes", "No", "No", "Mixtures"))
kable(tab,
      caption = "Features of packages for fitting the Plackett-Luce model.") %>%
    kable_styling()
```

# Methods

## Extended Plackett-Luce model

The **PlackettLuce** package permits rankings of the form

$$R = \{C_1, C_2, \ldots, C_J\}$$

where the items in set $C_1$ are ranked higher than (better than) the items
in $C_2$, and so on. If there are multiple objects in set $C_j$ these items
are tied in the ranking. For a set $S$, let

$$f(S) = \delta_{|S|} \left(\prod_{i \in S} \alpha_i \right)^\frac{1}{|S|}$$

where $|S|$ is the cardinality of the set, $\delta_n$ is a parameter
representing the prevalence of ties of order $n$, and $\alpha_i$ is a parameter
representing the worth of item $i$. Then under an extension of the
Plackett-Luce model allowing ties up to order $D$, the probability of the
ranking $R$ is given by

\begin{equation}
\prod_{j = 1}^J \frac{f(C_j)}{
\sum_{k = 1}^{\text{min}(D_j, D)} \sum_{S \in {A_j \choose k}} f(S)}
(\#eq:PL)
\end{equation}

where $D_j$ is the cardinality of $C_j$, $A_j$ is the set of alternatives from
which $C_j$ is chosen, and $A_j \choose k$ is all the possible choices of $k$
items from $A_j$. The value of $D$ can be set to the maximum number of tied
items observed in the data, so that $\delta_n = 0$ for $n > D$.

When the worth parameters are constrained to sum to one, they represent the
probability that the corresponding item comes first in a ranking of all items,
given that first place is not tied.

### Pudding example (with ties)

When each ranking contains only two items, then the model in Equation
\@ref(eq:PL) reduces to extended Bradley-Terry model proposed by
@Davidson1970 for paired comparisons with ties. The `pudding` data set,
available in **PlackettLuce** provides the data from Example 2 of that paper, in
which respondents were asked to test two brands of chocolate pudding from a
total of six brands. For each comparison of brands $i$ and $j$, the data set
gives the frequencies that brand $i$ was preferred ($w_{ij}$), that brand $j$
was preferred ($w_{ji}$) and that the brands were tied ($t_{ij}$).

```{r}
library(PlackettLuce)
head(pudding)
```

First we create a matrix representing each unique ranking, as required by
`PlackettLuce`, the model-fitting function in **PlackettLuce**

```{r}
nr <- 3*nrow(pudding)
R <- matrix(0, nrow = nr, ncol = 6,
            dimnames = list(NULL, seq_len(6)))
i <- rep(pudding$i, 3)
j <- rep(pudding$j, 3)
R[cbind(seq_len(nr), i)] <- rep(c(1, 2, 1), each = nrow(pudding))
R[cbind(seq_len(nr), j)] <- rep(c(2, 1, 1), each = nrow(pudding))
head(R, 3)
tail(R, 3)
```
The matrix `R` represents first the wins of $i$ over $j$, then the wins of
$j$ over $i$ and finally the ties, so is three times as long as the original
data. Each column represents a brand. In each row `0` represents an
unranked brand (not in the comparison), `1` represents the brand(s) ranked
in first place and `2` represents the brand in second place, if applicable.

This matrix can used to specify the rankings in the call to `PlackettLuce`,
however there are some advantages to creating a formal \code{"rankings"} object,
which `PlackettLuce` does internally if necessary:

```{r}
R <- as.rankings(R)
head(R)
tail(R)
```

The `as.rankings` method checks that the rankings are specified as dense
rankings, i.e. consecutive integers with no rank skipped for tied items,
recoding as necessary; drops rankings with less than two items since these are
uninformative, and adds column names if necessary. As can be seen above, the
print method displays the rankings in a more readable form.

To specify the full set of rankings, we need the frequency of each ranking,
which will be specified to the model0fitting function as a weight vector:
```{r}
w <- unlist(pudding[c("w_ij", "w_ji", "t_ij")])
```

Now we can fit the model with `PlackettLuce`, passing the rankings matrix
and the weight vector as arguments. Setting `npseudo = 0` means that standard
maximum likelihood estimation is performed and `maxit = 7` limits the number of
iterations to obtain the same worth parameters as @Davidson1970:
```{r}
mod <- PlackettLuce(R, weights = w, npseudo = 0, maxit = 7)
coef(mod, log = FALSE)
```
Note here we specify `log = FALSE` to give the parameterization as in Equation
\@ref(eq:PL). In the next section we discuss why it is more appropriate to use
the log scale for inference.

## Inference

A standard way to report model parameters is to report them along with their
corresponding standard error. This is an indication of the estimate's precision,
however implicitly this invites comparison with zero. Such comparison is made
explicit in many summary methods for models in R, with the addition of
partial t or Z tests testing the null hypothesis that the parameter is
equal to zero, given the other parameters in the model. However this hypothesis
is generally not of interest for the worth parameters in a Plackett-Luce model:
we expect most items to have *some* worth, the question is whether the items
differ in their worth. In addition, a Z test based on asymptotic normality of
the maximum likelihood estimate will not be appropriate for worth parameters
near zero or one, since it does not take account of the fact that the parameters
cannot be outside of these limits.

On the log scale however, there are no bounds on the parameters and we can set
a reference level to provide meaningful comparisons. By default, the summary
method for \code{"PlackettLuce"} objects sets the first item as the reference:

```{r}
summary(mod)
```

None of the Z tests for the item parameters provides significant evidence
against the null hypothesis, which is consistent with the test for equal
preferences presented in @Davidson1970. The tie parameter is alo shown on the
log scale here, but it is an integral part of the model rather than a parameter
of interest for inference, and its scale is not relevant.

The reference level for the item parameters can be changed via the `ref`
argument, for example setting to `NULL` sets the mean worth as the reference:

```{r}
summary(mod, ref = NULL)
```

As can be seen from the output above, the standard error of the item parameters
changes with the reference level. Therefore in cases where there is not a
natural reference (e.g. own brand versus competitor's brands), the inference can
depend on an arbitrary choice. This problem can be handled through the use of
*quasi standard errors* that remain constant for a given item regardless of the
reference. In addition quasi standard errors are defined for the reference item,
so even in cases where there is a natural reference, the uncertainty around the
worth of that item can still be represented.

Quasi standard errors for the item parameters are implemented via a method for
the `qvcalc` function from the **qvalc** package:

```{r}
qv <- qvcalc(mod)
qv
```

Again by default, the first item is taken as the reference, but this may be
changed via a `ref` argument. The plot method for the returned object visualizes
the item parameters (log-worth parameters) along with comparison intervals -
item parameters for which the comparison intervals do not cross are
significantly different:

```{r pudding-qv, fig.cap = "Worth of brands of chocolate pudding. Intervals based on quasi-standard errors."}
plot(qv, xlab = "Brand of pudding", ylab = "Worth (log)", main = NULL)
```

## Disconnected networks

The wins and losses between items can be represented as a directed network. For
example, consider the following set of paried comparisons:

```{r}
R <- matrix(c(1, 2, 0, 0,
              2, 0, 1, 0,
              1, 0, 0, 2,
              2, 1, 0, 0,
              0, 1, 2, 0), byrow = TRUE, ncol = 4,
            dimnames = list(NULL, LETTERS[1:4]))
R <- as.rankings(R)
```

The `adjacency` function from **PlacketLuce** can be used to convert these to an
adjacency matrix where element $(i, j)$ is the number of times item $i$ is
ranked higher than item $j$:
```{r}
A <- adjacency(R)
A
```
Using functions from **igraph** we can visualise the corresponding network:
```{r always-loses, fig.cap = "Network representation of toy rankings.", fig.small = TRUE}
library(igraph)
net <- graph_from_adjacency_matrix(A)
plot(net, edge.arrow.size = 0.5, vertex.size = 30)
```
For the worth parameters to have finite maximum likelihood estimates (MLEs) and
standard errors, the network must be strongly connected, i.e. there must be a
path of wins and a path of losses between each pair of items. In the example
above, A, B and C are strongly connected. For example, C directly loses against
B and although C never directly beats B, it does beat A and A in turn beats B,
so C indirectly beats B. Similar paths of wins and losses can be found for all
pairs of A, B and C. On the other hand D is only observed to lose, therefore the
MLE of the worth would be zero, with infinite standard error.

If one item always wins, the MLE of the worth would be one with infinite
standard error. Or if there are clusters of items that are strongly connected
with each other, but disconnected or connected only by wins or only by loses
(weakly connected) to other clusters, then the maximum likelihood estimates are
undefined, because there is no information on the relative worth of the
clusters or one cluster is infinitely worse than the other.

The connectivity of the network can be checked with the `connectivity` function
from **PlackettLuce**
```{r}
connectivity(A)
```
If the netwrok is not strongly connected, information on the clusters within
the network is returned. In this case a model could be estimated excluding item
D:
```{r}
R2 <- R[, -4]
R2
mod <- PlackettLuce(R2, npseudo = 0)
summary(mod)
```
Note that since `R` is a rankings object, the rankings are automatically
updated when items are dropped, so in this case the paired comparison with item
D is dropped.

By default however **PlackettLuce** provides a way to handle disconnected/weakly
connected networks, through the addition of pseudo-rankings. This works by
adding a win and a loss between each item and a hypothetical or ghost item with
fixed worth. This makes the network strongly connected so all the worth
parameters are estimable. It also has an interpretation as a Bayesian prior, in
particular a non-informative prior where all items have equal worth.

The `npseudo` argument defines the number of wins and loses with the ghost item
that are added for each real item. Setting `npseudo = 0 ` doesn't add any
pseudo-rankings, so `PlackettLuce` will return the standard MLE, if the
network is strongly connected, and throw an error otherwise. The larger
`npseudo` is, the stronger the influence of the prior, so by default `npseudo`
is set to 0.5, so each pseudo-ranking is weighted by 0.5. This is enough to
connect the network, but is a weak prior. In this toy example, the item
parameters change quite considerably:
```{r}
mod2 <- PlackettLuce(R)
coef(mod2)
```
This is because there are only 5 rankings, so there is not much information in
the data. In more realistic examples, the default prior will have a weak
shrinkage effect, shrinking the item parameters towards $1/N$, where $N$ is the
number of items.

For a practical example, we consider the NASCAR data from @Hunter2004. This
collects the results of the 36 races in the 2002 NASCAR season in the United
States. Each race involves 43 drivers out of a total of 87 drivers. The
`d_nascar` data provided by **PlackettLuce** records the results as an ordering
of the drivers in each race:
```{r}
data(nascar)
nascar[1:2, 1:45]
```
For example, in the first race, driver 83 came first, followed by driver 18 and
so on. Ranks 43 to 87 are zero for all races. We can convert these orderings
to rankings using `as.rankings` with `input = "ordering"`:
```{r}
R <- as.rankings(nascar, input = "ordering")
R[1:2,]
```
The names corresponding to the driver IDs are available as an attribute of
`nascar`; since the columns of `R` now correspond to the drivers, we can use
these as the column names:
```{r}
colnames(R) <- attr(nascar, "drivers")
R[1:3, 1:3, as.rankings = FALSE]
R[1:3]
```
Maximum likelihood estimation cannot be used in this example, because four
drivers placed last in each race they entered. So @Hunter2004 dropped these
four drivers to fit the Plackett-Luce model, which we can reproduce as follows:
```{r}
keep <- seq_len(83)
R2 <- R[, keep]
mod <- PlackettLuce(R2, npseudo = 0)
```
In order to demonstrate the correspondene with the results from @Hunter2004, we
order the item parameters by the deriver's average rank:
```{r}
avRank <- apply(R, 2, function(x) mean(x[x > 0]))
coefs <- round(coef(mod)[order(avRank[keep])], 2)
head(coefs, 3)
tail(coefs, 3)
```
Now we fit the Plackett-Luce model to the full data, using the default
pseudo-rankings method. In this case the default iterative scaling method does
not perform very well, so we switch to the L-BFGS algorithm:
```{r}
mod2 <- PlackettLuce(R, method = "L-BFGS")
```
For items that were in the previous model, we see that the log-worth parameters
generally shrink towards zero:
```{r}
coefs2 <- round(coef(mod2), 2)
coefs2[names(coefs)[1:3]]
coefs2[names(coefs)[81:83]]
```
The new items have relative large negative log worth
```{r}
coefs2[84:87]
```
Nonetheless, the estimates are finite and have finite standard errors:
```{r, cache = TRUE}
coef(summary(mod2))[84:87,]
```
Note that the reference here is simply the driver that comes first
alphabetically: A. Cameron. We can plot the quasi-variances for a better
comparison:
```{r nascar-qv, fig.cap = "Ability of drivers based on NASCAR 2002 season. Intervals based on quasi-standard errors.", cache = TRUE}
qv <- qvcalc(mod2)
qv$qvframe <- qv$qvframe[order(coef(mod2)),]
plot(qv, xlab = NULL, ylab = "Ability (log)", main = NULL, xaxt="n")
axis(1, at = seq_len(87), labels = rownames(qv$qvframe), las = 2, cex.axis = 0.7)
```
Although the pseudo-rankings are only necessary to add when the network is
incomplete, the default behaviour is always to use them (with a weight of 0.5)
because the small shrinkage effect reduces the bias of the estimates.

# Plackett-Luce Trees

A Plackett-Luce model that assumes the same worth parameters across all rankings
may sometimes be an over-simplification. For example, if rankings are made by
different judges, the worth parameters may vary between judges with different
characteristics. Model-based partitioning provides an automatic way to determine
subgroups of the judges with significantly different sets of worth parameters,
based on judge covariates. A Plackett-Luce tree is created via the following
steps:

1. Fit a Plackett-Luce model to the full data.
2. Asses the stability of the worth parameters with respect to each available
covariate.
3. If there is significant instability, split the full data by the covariate
with the strongest instability and use the cut-point with the highest
improvement in model fit.
4. Repeat steps 1-3 until there are no more significant instabilities, or a
split produces a sub-group below a given size threshold.

This is an extension of Bradley-Terry trees, implented in the R package **psychotree** and described in more detail by @Strobl2011.

To illustrate this approach, we consider data from a trial of different
varieties of bean in Nicaragua, run by Bioversity International. Farmers were
asked to grow three experimental varieties of bean in one of the growing
seasons, Primera (May - August), Postrera (September - October) or Apante
(November - January). At the end of the season, they were asked which variety
they though was best and which variety they thought was worse, to give a ranking
of the three varieties. In addition, they were asked to compare each trial
variety to the standard local variety and say whether it was better or worse.

The data are provided as the dataset `beans` in Plackett-Luce. The data require
some preparation to collate the rankings. First we consider the best and
worst rankings. These give the variety the farmer though was best or worst,
coded as A, B or C for the first, second or third variety assigned to the farmer
respectively.
```{r}
data(beans)
head(beans[c("best", "worst")], 2)
```
We convert these to numeric values, allowing us to impute the middle-ranked
variety (a strict ranking is assumed here, so the sum of each row should be 6)
```{r}
beans <- within(beans, {
    best <- match(best, c("A", "B", "C"))
    worst <- match(worst, c("A", "B", "C"))
    middle <- 6 - best - worst
})
head(beans[c("best", "middle", "worst")], 2)
```
This gives an ordering of the three varieties the farmer was given. The names of
these varieties are stored in separate columns
```{r}
varieties <- as.matrix(beans[c("variety_a", "variety_b", "variety_c")])
head(varieties, 2)
```
So we can convert the variety IDs to the variety names
```{r}
n <- nrow(beans)
beans <- within(beans, {
    best <- varieties[cbind(seq_len(n), best)]
    worst <- varieties[cbind(seq_len(n), worst)]
    middle <- varieties[cbind(seq_len(n), middle)]
})
head(beans[c("best", "middle", "worst")], 2)
```
Next we convert these orderings to sub-rankings of the full set of
varieties, including the local variety as an additional item, so that we can
add the paired comparisons shortly:
    ```{r}
lab <- c("Local", sort(unique(as.vector(varieties))))
R <- as.rankings(beans[c("best", "middle", "worst")],
                 input = "ordering", labels = lab)
```
The comparisons with the local variety are stored in another set of columns
```{r}
head(beans[c("var_a", "var_b", "var_c")], 2)
```
The following converts each of these columns to a matrix of ordered pairs:
```{r}
paired <- list()
for (id in c("a", "b", "c")){
    ordering <- matrix("Local", nrow = n, ncol = 2)
    worse <- beans[[paste0("var_", id)]] == "Worse"
    ## name of winner
    ordering[!worse, 1] <- beans[[paste0("variety_", id)]][!worse]
    ## name of loser
    ordering[worse, 2] <- beans[[paste0("variety_", id)]][worse]
    paired[[id]] <- ordering
}
head(paired[[id]])
```
Again we convert these orderings to sub-rankings of the full set of varieties
and combine them with the rankings of order three:
```{r}
paired <- lapply(paired, as.rankings, input = "ordering", labels = lab)
R <- rbind(R, paired[["a"]], paired[["b"]], paired[["c"]])
```
In order to fit a Plackett-Luce tree, we need to create a
\code{"grouped_rankings"} object, that defines how the rankings map to the
covariate values. In this case we wish to group by each record in
the original data set, so we create a \code{"grouped_rankings"} object as
follows:
```{r}
G <- grouped_rankings(R, rep(seq_len(n), 4))
format(head(G, 2), width = 50)
```
For each record in the original data, we have three covariates: \code{season}
the season-year the beans were planted, \code{year} the year of planting,
and \code{rx5day} the maximum 5-day rainfall. The covariates will be used to
fit a Plackett-Luce tree
```{r}
beans$season <- factor(beans$season,
                       labels = c("Ap - 15", "Ap - 16", "Ap - 17", "Po - 15",
                                  "Po - 16", "Pr - 16"))
beans$year <- factor(beans$year)
tree <- pltree(G ~ ., data = beans[c("season", "year", "rx5day")], minsize = 5)
tree
```
In this case there are two nodes defined by the seasons.
```{r}
plot(tree)
```

# Appendix

For the package comparison in Table \@ref(tab:timings-kable), the model was
fitted to aggregated rankings where possible (PlackettLuce, hyper2, pmr).
Arguments were set to obtain the maximum likelihood estimate, using the default
iterative scaling algorithm for PlackettLuce. The functions were run with their
default convergence criteria; the number of iterations for StatRank was set so
that the log-likehood on exit was equal to the log-likelihood returned by the
other functions with relative tolerance 1e-6.

```{r chunk2}
```{r wrappers, eval = FALSE}
```{r timings, eval = FALSE}
```

# References
