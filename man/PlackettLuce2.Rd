% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PlackettLuce2.R
\name{PlackettLuce2}
\alias{PlackettLuce2}
\title{Fit Plackett-Luce Model}
\usage{
PlackettLuce2(rankings, ref = NULL, network = c("adaptive", "pseudodata",
  "connected", "cluster"), npseudo = 1, method = c("iterative scaling",
  "BFGS", "L-BFGS"), epsilon = 1e-07, steffensen = 1e-04, maxit = 100,
  trace = FALSE, verbose = TRUE)
}
\arguments{
\item{rankings}{a matrix of dense rankings, see examples.}

\item{ref}{an integer or character string specifying the reference item (for which log ability will be set to zero). If \code{NULL} the first item is used.}

\item{network}{the network of rankings on which to base the model:
\code{"adaptive"} (default: rankings plus pseudodata if network not strongly connected),
\code{"pseudodata"} (rankings plus pseudodata),
\code{"connected"} (rankings if network strongly connected, fail otherwise),
\code{"cluster"} (the largest strongly connected cluster).}

\item{npseudo}{when using pseudodata: the number of wins and losses to add
between each object and a hypothetical reference object.}

\item{method}{the method to be used for fitting: \code{"iterative scaling"} (default: iterative scaling to sequentially update the parameter values), \code{"BFGS"} (the BFGS optimisation algorithm through the \code{\link{optim}} interface), \code{"L-BFGS"} (the limited-memory BFGS optimisation algorithm as implemented in the \code{\link{lbfgs}} package).}

\item{epsilon}{the maximum absolute difference between the observed and
expected sufficient statistics for the ability parameters at convergence.}

\item{steffensen}{a threshold defined as for \code{epsilon} after which to
apply Steffensen acceleration to the iterative scaling updates.}

\item{maxit}{the maximum number of iterations.}

\item{trace}{logical, if \code{TRUE} show trace of iterations.}

\item{verbose}{logical, if \code{TRUE} show messages from validity checks.}
}
\value{
An object of class "PlackettLuce", which is a list containing the
following elements:
\item{call}{ The matched call. }
\item{coefficients}{ The model coefficients. }
\item{loglik}{ The log-likelihood. }
\item{iter}{ The number of iterations run. }
}
\description{
Fit a Plackett-Luce model to a set of rankings. The rankings may be partial
(not all objects ranked) and include ties of any order.
}
\details{
In order for the maximum likelihood estimate of an object's ability to be
defined, the network of rankings must be strongly connected. This means that
in every possible partition of the objects into two nonempty subsets, some
object in the second set is ranked higher than some objects in the first set
at least once.

If the network of rankings is not strongly connected, or the network is
sparse, then pseudodata may be used to connect the network and reduce the
bias in the ability estimates. This approach posits a hypothetical object
with log-ability 0 and adds \code{npseudo} wins and \code{npseudo} losses
to the set of rankings.

The paramater \code{npseudo} is the prior strength.  With \code{npseudo = 0}
we have the MLE as the posterior mode.  As \code{npseudo} approaches
infinity the log-ability estimates all shrink towards 0. The default,
\code{npseudo = 1}, is sufficient to connect the network and has a weak
shrinkage effect.
}
\examples{
# Six partial rankings of four objects, 1 is top rank, e.g
# first ranking: item 1, item 2
# second ranking: item 2, item 3, item 4, item 1
# third ranking: items 2, 3, 4 tie for first place, item 1 second
R <- matrix(c(1, 2, 0, 0,
              4, 1, 2, 3,
              2, 1, 1, 1,
              1, 2, 3, 0,
              2, 1, 1, 0,
              1, 0, 3, 2), nrow = 6, byrow = TRUE)
colnames(R) <- c("apple", "banana", "orange", "pear")

mod <- PlackettLuce(R)
coef(mod)
}
