% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rankings.R
\name{rankings}
\alias{rankings}
\alias{as.rankings}
\alias{as.rankings.Matrix}
\alias{as.rankings.matrix}
\title{Rankings Objects}
\usage{
rankings(data, id, item, rank, verbose = TRUE, ...)

as.rankings(x, verbose = TRUE, ...)

\method{as.rankings}{Matrix}(x, verbose = TRUE, ...)

\method{as.rankings}{matrix}(x, verbose = TRUE, ...)
}
\arguments{
\item{data}{a data frame with columns specified by \code{id}, \code{item} and
\code{rank}.}

\item{id}{an index of \code{data} specifying the column containing ranking
IDs.}

\item{item}{an index of \code{data} specifying the column containing item
IDs,}

\item{rank}{an index of \code{data} specifying the column containing item
ranks.}

\item{verbose}{logical; if \code{TRUE} print messages when changes are made
to rankings data.}

\item{...}{further arguments passed to/from methods.}

\item{x}{a matrix with one column per item and one row per ranking.}
}
\value{
a \code{"rankings"} object, which is a matrix of rankings with
attributes
\code{membership}{a labelled vector of indices specifying membership of
clusters in the network of items}
\code{csize}{the sizes of clusters in the network of items}
\code{no}{the number of clusters in the network of items}
}
\description{
Create a \code{"rankings"} object from data or convert a matrix of rankings
to a \code{"rankings"} object. These functions validate that the data are
(possibly partial) dense rankings, recoding as necessary. The connectivity of
inferred pairwise comparisons is also checked and information on clusters in
the network is returned.
}
\details{
Each ranking \eqn{r} should rank items from 1 (first place) to \eqn{n_r}
(last place). Items not ranked should have a rank of 0. Tied items are given
the same rank with no rank skipped. For example {1, 0, 2, 1}, ranks the first
and fourth items in first place and the third item in second place; the
second item is unranked.

\code{as.rankings} with throw an error if \code{x} contains anything other
than integers \code{0:M} where M is the maximum rank.

If the ranks are not in dense form, they will be recoded, e.g. {2, 2, 0, 4}
will become {1, 1, 0, 2}.

The underlying network of paired comparisons is inferred and checked for
connectivity. A warning is given if the network is not strongly connected,
i.e. with at least one win and one loss between all partitions of the network
into two groups. Attributes are returned on the clusters in the network - if
the network is strongly connected, all items belong to the same cluster.
}
\examples{
# create rankings from data in long form

## many issues with the raw rankings!
x <- data.frame(ranking = c(rep(1:4, each = 4), 5, 5, 5),
                letter = c(LETTERS[c(1:3, 3, 1:4, 2:5, 1:2, 1)], NA,
                           LETTERS[3:5]),
                rank = c(4:1, rep(NA, 4), 3:4, NA, NA, 1, 3, 4, 2, 2, 2, 3))
rankings(x, id = "ranking", item = "letter", rank = "rank")

# convert existing matrix of rankings

## weakly connected network:
## one win between two clusters
X <- matrix(c(1, 2, 0, 0,
              2, 1, 3, 0,
              0, 0, 1, 2,
              0, 0, 2, 1), ncol = 4, byrow = TRUE)
R <- as.rankings(X)
attr(R, "membership")

## two weakly connected items:
## item 1 always loses; item 4 only wins against item 1
X <- matrix(c(4, 1, 2, 3,
              0, 2, 1, 3), nr = 2, byrow = TRUE)
R <- as.rankings(X)
attr(R, "membership")

## item 1 always wins; item 4 always loses
X <- matrix(c(1, 2, 3, 4,
              1, 3, 2, 4), nr = 2, byrow = TRUE)
R <- as.rankings(X)
attr(R, "membership")

## all in separate clusters: always 1 > 2 > 3 > 4
## also miscoded rankings and redundant ranking
X <- matrix(c(1, 2, 3, 4,
              1, 0, 2, 3,
              1, 1, 2, 0,
              1, 0, 3, 4,
              2, 2, 0, 4,
              0, 0, 3, 0,
              2, 4, 0, 0), ncol = 4, byrow = TRUE)
              R <- as.rankings(X)
R
attr(R, "recoded")
attr(R, "membership")
}
